/*******************************************************************************
 *
 * TRIQS: a Toolbox for Research in Interacting Quantum Systems
 *
 * Copyright (C) 2013 by M. Ferrero, O. Parcollet, H.Hafermann, T.Ayral
 *
 * TRIQS is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option) any later
 * version.
 *
 * TRIQS is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * TRIQS. If not, see <http://www.gnu.org/licenses/>.
 *
 ******************************************************************************/
#include <solver_core.hpp>
#include <evaluate_vertex.hpp>
using triqs::h5::h5_write;
#define __FILENAME__ (strrchr(__FILE__, '/') ? strrchr(__FILE__, '/') + 1 : __FILE__)
#define REMOVE_EXT(X) (str(X).substr(0,str(X).find_last_of(".")))
#define H5_DUMP(X){ \
 triqs::h5::file hfile(REMOVE_EXT(__FILENAME__)+".output.h5",exists(REMOVE_EXT(__FILENAME__)+".output.h5") ? H5F_ACC_RDWR: H5F_ACC_TRUNC); \
  h5_write(hfile, BOOST_PP_STRINGIZE((X)), (X));  \
  hfile.close();  \
}
using namespace triqs::applications::impurity_solvers::ctqmc_seg;
using namespace triqs;
using namespace triqs::gfs;
using triqs::arrays::matrix;

void run_solver(int n_c){

 triqs::mpi::communicator world;

 int n_w_f_vertex = 50;
 int n_w = 200;
 int n_w_b_nn = 25;
 int n_w_b_vertex = 25;
 long n_cycles = n_c / world.size();

 double beta = 20.0;
 double U = 2.0;
 double mu = 1.0;
 double epsilon = 0.0;
 long n_warmup_cycles = 100;
 long random_seed = 23488 + 28 * world.rank();

 double l=0.5;
 double om0=1.0;

 constructor_parameters_t param_constructor;
 solve_parameters_t param_solve;

 param_constructor.gf_struct = {{"up",{0}},{"down",{0}}};
 param_constructor.n_w = n_w;
 param_constructor.n_w_b_nn = n_w_b_nn;
 param_constructor.beta = beta;

 solver_core ctqmc(param_constructor);

 //param_solve.U = matrix<double>({{0.0,U},{U,0.0}});
  param_solve.h_int = U*n("up",0)*n("down",0);
 param_solve.n_cycles = n_cycles;
 param_solve.length_cycle = 50;
 param_solve.n_warmup_cycles = n_warmup_cycles;
 param_solve.random_seed = random_seed;
 param_solve.measure_g2w = true;
 param_solve.measure_f2w = true;
 param_solve.measure_gt = false;
 param_solve.measure_gw = true;
 param_solve.measure_nnw = true;
 param_solve.measure_nn = true;
 param_solve.evaluate_vertex = true;
 param_solve.dynamical_U = true;
 param_solve.n_w_f_vertex = n_w_f_vertex;
 param_solve.n_w_b_vertex = n_w_b_vertex;

 triqs::clef::placeholder<0> om_;
 auto delta_w = gf<imfreq>({beta, Fermion, param_constructor.n_w}, {1,1});
 delta_w(om_) << 1.0 / (om_ - epsilon);
 ctqmc.G0_iw()[0](om_) << 1.0 / (om_ + mu + (-1.0)*delta_w(om_));
 ctqmc.G0_iw()[1](om_) << 1.0 / (om_ + mu + (-1.0)*delta_w(om_));
 ctqmc.D0_iw()(om_) << 0.25*l*l*(1/(om_-om0) - 1/(om_+om0))*matrix<double>({{1,1},{1,1}});

 ctqmc.solve(param_solve);
 if (world.rank() == 0) {
  H5_DUMP(ctqmc.g2w_view());
  H5_DUMP(ctqmc.f2w_view());
  H5_DUMP(ctqmc.G_iw());
  H5_DUMP(ctqmc.K_tau());
  H5_DUMP(ctqmc.Sigma_iw());
  H5_DUMP(ctqmc.nn_iw());
  H5_DUMP(ctqmc.nn());
 }
}

int main(int argc, char ** argv) {
  triqs::mpi::environment env(argc, argv);
  if(argc==1){  run_solver(500);}
  else{
   if(argc==2){
   int n_c = atoi(argv[1]);
   run_solver(n_c);
   }
   else{ TRIQS_RUNTIME_ERROR << "Wrong # of args, should be n_cycles";}
  }
}
